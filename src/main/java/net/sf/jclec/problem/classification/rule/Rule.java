package net.sf.jclec.problem.classification.rule;

import net.sf.jclec.IFitness;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.exprtree.fun.ExprTreeFunction;
import net.sf.jclec.problem.classification.IClassifier;
import net.sf.jclec.problem.util.dataset.IMetadata;
import net.sf.jclec.problem.util.dataset.IExample;

/**
 * Abstract classification rule that extends an expression tree
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Juan Luis Olmo
 */

public abstract class Rule extends ExprTreeFunction implements IClassifier
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8174242256644010121L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////

	/** Rule consequent */
	
	protected double consequent = -1;
	
	/** Rule fitness */
	
	protected IFitness fitness;
	
	/** Actual instance for the rule */

	private IExample actualInstance;
		
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Default (empty) constructor
	 */
	
	public Rule()
	{
		super();
	}
	
	/**
	 * Constructor
	 * 
	 * @param antecedent The antecedent of the rule
	 */
	
	public Rule(ExprTree antecedent)
	{
		super();
		setAntecedent(antecedent);
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/** 
	 *  Access to the rule antecedent
	 *  
	 *  @return the antecedent of the rule
	 */
	
	public ExprTree getAntecedent() 
	{
		return this.code;
	}
	
	/** 
	 *  Set rule antecedent
	 *  
	 *  @param antecedent rule antecedent
	 */
	
	public void setAntecedent(ExprTree antecedent) 
	{
		this.code = antecedent;
	}
	
	/** 
	 *  Access to rule consequent
	 *  
	 *  @return rule consequent
	 */
	
	public double getConsequent() 
	{
		return consequent;
	}
	
	/** 
	 *  Set rule consequent
	 *  
	 *  @param consequent rule consequent
	 */

	public void setConsequent(double consequent) 
	{
		this.consequent = consequent;
	}
	
	/** 
	 *  Access to the rule fitness
	 *  
	 *  @return the fitness of the rule
	 */
	
	public IFitness getFitness() 
	{
		return fitness;
	}
	
	/** 
	 *  Set the rule fitness
	 *  
	 *  @param fitness the fitness of the rule
	 */
	
	public void setFitness(IFitness fitness) 
	{
		this.fitness = fitness;
	}
	
	/**
	 * Gets the actual instance for evaluating the rule
	 * 
	 * @return the actualInstance
	 */
	
	public IExample getActualInstance() {
		return actualInstance;
	}
	
	/** 
	 *  Sets the actual instance for evaluating the rule
	 *  
	 *  @param instance the instance
	 */
	
	public void setActualInstance(IExample instance) {
		this.actualInstance = instance;
	}
	
	/** 
	 *  Checks if the rule covers an instance
	 *  
	 *  @param instance the instance
	 *  
	 *  @return true or false
	 */

	public Object covers(IExample instance)
	{
		// Set actual instance
		setActualInstance(instance);
		// Execute code, using this as context
		return super.<Object>execute(this);
	}

	/** 
	 *  Shows the complete rule antecedent and consequent
	 *  
	 *  @return the rule
	 */
	
	public abstract String toString(IMetadata metadata);

	/**
     * Obtain the number of conditions of the rule
     * 
     * @return number of conditions
     */

	public abstract int getConditions();
	
	/**
	 * Implementation of copy()
	 * 
	 * {@inheritDoc}
	 */
	
	public abstract Rule copy();
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting java.lang.Object methods
	/////////////////////////////////////////////////////////////////
	
	@Override
	public boolean equals(Object other)
	{
		if(getAntecedent().equals(((Rule) other).getAntecedent()))
			return true;
		else
			return false;
	}
}