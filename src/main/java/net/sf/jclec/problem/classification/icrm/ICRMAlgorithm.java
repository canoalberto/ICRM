package net.sf.jclec.problem.classification.icrm;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IIndividual;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.problem.classification.classic.ClassicClassificationAlgorithm;
import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.classic.classifier.CrispRuleBase;
import net.sf.jclec.problem.classification.exprtree.MultiExprTreeRuleIndividual;
import net.sf.jclec.problem.classification.icrm.fitting.ICRMFittingAlgorithm;
import net.sf.jclec.problem.classification.icrm.fitting.ICRMFittingEvaluator;
import net.sf.jclec.problem.classification.icrm.ga.ICRMGAAlgorithm;
import net.sf.jclec.problem.classification.rule.Rule;
import net.sf.jclec.problem.classification.rule.crisp.CrispRule;
import net.sf.jclec.problem.util.dataset.IExample;

import org.apache.commons.configuration.Configuration;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * A. Cano, A. Zafra, and S. Ventura. An Interpretable Classification Rule Mining Algorithm. Information Sciences, vol. 240, 1-20, 2013.
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMAlgorithm extends ClassicClassificationAlgorithm
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	/** Individuals recombinator */

	protected ICRMMutator mutator;

	/** Actual individuals set */

	protected List<IIndividual>[] bset;

	/** Individuals selected as parents */

	protected transient List<IIndividual>[] pset;

	/** Individuals generated */

	protected transient List<IIndividual>[] cset;

	/** Individuals mutated */

	protected transient List<IIndividual>[] mset;
	
	/** List of the classes not-yet covered */

	private List<Integer> nonCoveredClasses = new ArrayList<Integer>();
	
	/** List of created rules for each attribute */

	private List<IIndividual>[] initialRules;
	
	/** A copy of the instances from the train dataset */

	private ArrayList<IExample> trainSetCopy;

	private boolean existsIndividualBeatable;

	private int numberAttributes;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	/**
	 * Empty (default) constructor
	 */

	public ICRMAlgorithm() {
		super();
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////

	/**
	 * @return the coveredClasses
	 */
	public List<Integer> getCoveredClasses() {
		return nonCoveredClasses;
	}
	
	/**
	 * @return the individuals of a class
	 */
	
	public List<IIndividual> getInhabitants(int Class)
	{
		return bset[Class];
	}
	
	/**
	 * @return the initialRules
	 */
	
	public List<IIndividual> getInitialRules(int attribute) {
		return initialRules[attribute];
	}
	
	/**
	 * @return the number of attributes
	 */
	public int getNumberAttributes() {
		return numberAttributes;
	}

	// ///////////////////////////////////////////////////////////////
	// ---------------------------- Implementing IConfigure interface
	// ///////////////////////////////////////////////////////////////

	/**
	 * Configuration method.
	 */

	public void configure(Configuration settings)
	{
		// Call super.configure() method
		super.configure(settings);

		prepare();
	}
	
	public void prepare()
	{
		classifier = new CrispRuleBase();

		numberAttributes = getTrainSet().getMetadata().numberOfAttributes();
		
		setMaxOfGenerations(numberAttributes);

		// Establishes the metadata for the species
		((ICRMExprTreeSpecies) species).setMetadata(getTrainSet().getMetadata());
		
		((ICRMExprTreeSpecies) species).setSymbols();

		// Recombinator
		mutator = new ICRMMutator(this);
	}

	// ///////////////////////////////////////////////////////////////
	// ---------------------------- Overwriting BaseAlgorithm methods
	// ///////////////////////////////////////////////////////////////

	@SuppressWarnings("unchecked")
	@Override
	protected void doInit()
	{
		bset = new ArrayList[getTrainSet().getMetadata().numberOfClasses()];
		pset = new ArrayList[getTrainSet().getMetadata().numberOfClasses()];
		mset = new ArrayList[getTrainSet().getMetadata().numberOfClasses()];
		cset = new ArrayList[getTrainSet().getMetadata().numberOfClasses()];
		
		// Create the initial rules only in the first execution
		if (initialRules == null) {
			trainSetCopy = getTrainSet().getExamples();
			initialRules = new ArrayList[numberAttributes];

			for (int i = 0; i < numberAttributes; i++)
				initialRules[i] = provider.provide(i);

			for (int i = 0; i < getTrainSet().getMetadata().numberOfClasses(); i++)
				nonCoveredClasses.add(i);
		}
		
		for (int i : nonCoveredClasses)
		{
			bset[i] = new ArrayList<IIndividual>();
			pset[i] = new ArrayList<IIndividual>();
			mset[i] = new ArrayList<IIndividual>();
			
			ICRMGAAlgorithm gaAlgorithm = new ICRMGAAlgorithm(this,i,initialRules, getTrainSet());
			
			gaAlgorithm.execute();

			for(int j = 0; j < numberAttributes; j++)
			{
				ExprTree genotype = ((ICRMIndividual) gaAlgorithm.getInhabitants(j).get(0)).getGenotype();
				
				CrispRule phenotype = new CrispRule(genotype);
				phenotype.setConsequent(i);
				
				ICRMIndividual individual = new ICRMIndividual(genotype, phenotype, null, getTrainSet().copy());
				
				bset[i].add(individual);
			}

			// Evaluate individuals
			evaluator.evaluate(bset[i]);
			
			bset[i] = bettersSelector.select(bset[i], (int) Math.ceil(numberAttributes / 2.0));
		}
	}

	@Override
	protected void doSelection()
	{
		for (int i : nonCoveredClasses)
		{
			pset[i] = new ArrayList<IIndividual>();
			cset[i] = new ArrayList<IIndividual>();

			pset[i].addAll(bset[i]);
			cset[i].addAll(pset[i]);
		}
	}

	@Override
	protected void doGeneration()
	{
		for (int i : nonCoveredClasses)
		{
			// Recombine parents
			mset[i] = mutator.mutate(i,pset[i]);
			
			ArrayList<IIndividual> created = new ArrayList<IIndividual>();
			
			for(IIndividual ind : mset[i])
				if(ind != null)
				{
					((ICRMIndividual) ind).getDataset().setExamples(getTrainSet().getExamples());
					created.add(ind);
				}
			
			evaluator.evaluate(created);
			
			for(int j = 0; j < cset[i].size(); j++)
			{
				if(mset[i].get(j) != null && evaluator.getComparator().compare(cset[i].get(j).getFitness(), mset[i].get(j).getFitness()) < 0)
				{
					cset[i].set(j, mset[i].get(j));
				}
			}
		}
	}

	@Override
	protected void doReplacement() {
	}

	@Override
	protected void doUpdate()
	{
		existsIndividualBeatable = false;
		
		for (int i : nonCoveredClasses)
		{
			for(int j = 0; j < bset[i].size(); j++)
				if(bset[i].get(j).equals(cset[i].get(j)))
					((ICRMIndividual) cset[i].get(j)).beatable = false;
				else
					existsIndividualBeatable = true;
			
			bset[i] = bettersSelector.select(cset[i]);
		}
	}

	@Override
	protected void doControl()
	{
		if(!existsIndividualBeatable || maxOfGenerations >= maxOfGenerations)
		{
			double bestFitness = -1.0;
			int bestFitnessClass = 0, bestFitnessClassIndex = 0, index = 0;

			// Select the best individual
			for (int i : nonCoveredClasses)
			{
				double value = ((SimpleValueFitness) bset[i].get(0).getFitness()).getValue();

				if (value > bestFitness) {
					bestFitness = value;
					bestFitnessClass = i;
					bestFitnessClassIndex = index;
				}

				index++;
			}

			// Select the best rule for the best class
			Rule rule = (Rule) ((ICRMIndividual) bset[bestFitnessClass].get(0)).getPhenotype();
			rule.setConsequent(bestFitnessClass);
			rule.setFitness(bset[bestFitnessClass].get(0).getFitness());
			
			// Append the rule to the classifier
			((CrispRuleBase) classifier).addClassificationRule(rule);

			nonCoveredClasses.remove(bestFitnessClassIndex);

			// If all the classes have been covered, finishes the execution
			if (nonCoveredClasses.size() == 1)
			{
				((CrispRuleBase) classifier).setDefaultClass(nonCoveredClasses.get(0));
				getTrainSet().setExamples(trainSetCopy);
				
				if(((ICRMExprTreeSpecies) species).existNumericalAttributes())
				{
					ICRMFittingAlgorithm fitting = new ICRMFittingAlgorithm(this, (CrispRuleBase) classifier, new ICRMFittingEvaluator(getTrainSet()));
					fitting.execute();
					
					if(!classifier.equals((MultiExprTreeRuleIndividual) fitting.getInhabitants().get(0)))
					{
						classifier = ((MultiExprTreeRuleIndividual) fitting.getInhabitants().get(0)).getPhenotype();
					}
				}
				
				state = FINISHED;
				return;
			}

			// Remove the instances of the class covered
			removeInstances(bestFitnessClass);
			
			execution++;

			// Next iteration
			maxOfGenerations = 0;
			doInit();
			return;
		}
	}

	private void removeInstances(int Class)
	{
		ArrayList<IExample> instances = getTrainSet().getExamples();
		ArrayList<IExample> survivals = new ArrayList<IExample>();

		for(IExample instance : instances)
			if (((ClassicInstance) instance).getClassValue() != Class)
				survivals.add(instance);

		getTrainSet().setExamples(survivals);
	}
}