package net.sf.jclec.problem.classification.classic.classifier;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.problem.classification.classic.ClassicClassificationMetadata;
import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.classic.IClassicClassifier;
import net.sf.jclec.problem.classification.rule.Rule;
import net.sf.jclec.problem.classification.rule.RuleBase;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.IExample;
import net.sf.jclec.problem.util.dataset.IMetadata;

/**
 * Classic classifier by means of a base of crisp rules
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 * @author Jose M. Luna 
 * @author Juan Luis Olmo
 */

public class CrispRuleBase extends RuleBase implements IClassicClassifier
{	
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 1L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor
	 */
	
	public CrispRuleBase() {
		super();
	}
	
	/**
	 * Constructor
	 * 
	 * @param defaultC default class
	 */
	
	public CrispRuleBase(double defaultC) {
		super(defaultC);
	}
	
	/**
	 * Constructor
	 * 
	 * @param rules list of rules
	 * @param defaultC default class
	 */
	
	public CrispRuleBase(List<Rule> rules, double defaultC) {
		super(rules,defaultC);
	}
	
	/////////////////////////////////////////////////////////////////
	// ----------------------------------------------- Public methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Return the predicted by the classifier to the dataset
	 * 
	 * @param dataset the dataset
	 * @return array of class predictions
	 */
	
	public double[] classify(IDataset dataset) 
	{
		/** Get the dataset instances */
		ArrayList<IExample> instances = dataset.getExamples();
		
        int numInstances = instances.size();
        int numRules = rules.size();
        double [] result = new double[numInstances];
		boolean cover = false;
        
		// For each instance
        for(int i=0; i<numInstances; i++)
        {
        	// For each rule
        	for(int j=0; j<numRules; j++)
			{	            		
        		// If the rule covers the instance
				if((Boolean) rules.get(j).covers(instances.get(i)))
				{
					// Predict the class of the rule consequent
					result[i] = rules.get(j).getConsequent();
					cover = true;
					break;
				}
			}
		
        	// If any rule covers the instance, the predict the default class
			if(cover == false)
				result[i] = defaultClass;
			
			cover = false;
        }
    	return result;
	}

	/**
	 *  Return the predicted class to the instance
	 *  
	 *  @param instance The instance
	 *  @return the predicted class
	 */
	
	public double classify(IExample instance) 
	{	
		for(int i = 0; i < rules.size(); i++)
			if((Boolean) rules.get(i).covers(instance))
				return rules.get(i).getConsequent();
		
		return defaultClass;
	}
	
	/**
	 * Obtains the confusion matrix for a dataset
	 * 
	 * @param dataset the dataset
	 * @return the confusion matrix
	 */
	
	@Override
	public int[][] getConfusionMatrix(IDataset dataset)
	{
		ClassicClassificationMetadata metadata = (ClassicClassificationMetadata) dataset.getMetadata();
		int [][] confusionMatrix = new int[metadata.numberOfClasses()][metadata.numberOfClasses()];
		
		double[] predicted = classify(dataset);
		
		for(int i = 0; i < dataset.getExamples().size(); i++) 
			confusionMatrix[(int) (((ClassicInstance) dataset.getExamples().get(i)).getClassValue())][(int) predicted[i]]++;
		
		return confusionMatrix;
	}
	
	/** 
	 *  Shows the complete rule base, the rules and the default class
	 *  
	 *  @param metadata the metadata
	 *  @return the rule
	 */
	
	@Override
	public String toString(IMetadata metadata)
	{
		String result = new String();
		
		int numRules = rules.size();
		
		if(numRules > 0)
		{
			result = " 1 Rule: " + rules.get(0).toString(metadata) + System.getProperty("line.separator");	
	
			for (int i = 1; i < numRules; i++)
			   result += " " + (i+1) + " Rule: ELSE " + rules.get(i).toString(metadata) + System.getProperty("line.separator");	
	
			result += "Default: ("+ ((ClassicClassificationMetadata) metadata).getClassAttribute().getName() + " = " + ((ClassicClassificationMetadata) metadata).getClassAttribute().show(defaultClass) + ")" + System.getProperty("line.separator");
		}
		
		return result;
	}
	
	/**
	 * Implementation of copy()
	 * 
	 * {@inheritDoc}
	 */
	
	@Override
	public CrispRuleBase copy()
	{
		ArrayList<Rule> newRules = new ArrayList<Rule>();
		
		for(Rule rule : rules)
			newRules.add(rule.copy());
		
		return new CrispRuleBase(newRules, defaultClass);
	}
}