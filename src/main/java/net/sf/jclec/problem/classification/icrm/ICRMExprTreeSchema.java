package net.sf.jclec.problem.classification.icrm;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.exprtree.ExprTreeSchema;
import net.sf.jclec.exprtree.IPrimitive;
import net.sf.jclec.problem.classification.blocks.AttributeValue;
import net.sf.jclec.problem.classification.blocks.Equal;
import net.sf.jclec.problem.classification.blocks.GreaterOrEqual;
import net.sf.jclec.problem.classification.blocks.LessOrEqual;
import net.sf.jclec.problem.classification.blocks.NotEqual;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfContinuousValues;
import net.sf.jclec.problem.classification.blocks.RandomConstantOfDiscreteValues;
import net.sf.jclec.util.random.IRandGen;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMExprTreeSchema extends ExprTreeSchema 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8548482239030974796L;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------- Overwriting SyntaxTreeSchema methods
	/////////////////////////////////////////////////////////////////
	
	public List<ExprTree> createExprTree(int attributeIndex, int interval, ICRMExprTreeSpecies species, IRandGen randgen) 
	{
		List<ExprTree> created = new ArrayList<ExprTree>();
		
		ExprTree exprTree1 = new ExprTree();
		ExprTree exprTree2 = new ExprTree();
		
		// Create a IPrimitive with the attribute selected randomly from the dataset
		IPrimitive term = new AttributeValue();
		((AttributeValue) term).setAttributeIndex(attributeIndex);
		
		// Calculate the index of the attribute's interval terminal
		int intervalIndex = (attributeIndex*2)+1;
		
		double step;
		
		IPrimitive[] terminals = species.getGenotypeSchema().getTerminals();
		
		//Checks the attribute type and assign the value type
		switch(species.getMetadata().getAttribute(attributeIndex).getType())
		{
			case Numerical:
			{
				// Create a possible attribute's interval and choose one value randomly
				net.sf.jclec.util.range.Interval intervalDouble = ((RandomConstantOfContinuousValues) terminals[intervalIndex]).getInterval();
				RandomConstantOfContinuousValues valueDouble = new RandomConstantOfContinuousValues(randgen);
				valueDouble.setInterval(intervalDouble);
				
				double left,right;
				
				left = intervalDouble.getLeft();
				right = intervalDouble.getRight();
				step = (right-left) / 10.0;
				valueDouble.setValue(intervalDouble.getLeft() + interval*step);
				
				// Create the exprTree
				exprTree1.addBlock(new GreaterOrEqual());
				exprTree1.addBlock(term);
				exprTree1.addBlock(valueDouble);
				exprTree2.addBlock(new LessOrEqual());
				exprTree2.addBlock(term.copy());
				exprTree2.addBlock(valueDouble.copy());
				
				created.add(exprTree1);
				created.add(exprTree2);
				break;
			}
			case Integer:
			{
				// Create a possible attribute's interval and choose one value randomly
				net.sf.jclec.util.intset.Interval intervalInteger = ((RandomConstantOfDiscreteValues) terminals[intervalIndex]).getInterval();
				RandomConstantOfDiscreteValues valueInteger = new RandomConstantOfDiscreteValues(randgen);
				valueInteger.setInterval(intervalInteger);
				
				int left,right;
				
				left = intervalInteger.getLeft();
				right = intervalInteger.getRight();
				step = (right-left) / 10.0;
				
				if(right - left < 10)
				{
					valueInteger.setValue(randgen.choose(left,right+1));
				}
				else
				{
					Double value = new Double(interval*step);
					valueInteger.setValue(intervalInteger.getLeft() + value.intValue());
				}
				
				// Create the exprTree
				exprTree1.addBlock(new GreaterOrEqual());
				exprTree1.addBlock(term);
				exprTree1.addBlock(valueInteger);
				exprTree2.addBlock(new LessOrEqual());
				exprTree2.addBlock(term.copy());
				exprTree2.addBlock(valueInteger.copy());
				
				created.add(exprTree1);
				created.add(exprTree2);
				break;
			}
			case Categorical:
			{
				// Create a possible attribute's interval and choose one value randomly
				net.sf.jclec.util.intset.Interval intervalCategorical = ((RandomConstantOfDiscreteValues) terminals[intervalIndex]).getInterval();
				RandomConstantOfDiscreteValues valueCategorical = new RandomConstantOfDiscreteValues(randgen);
				valueCategorical.setInterval(intervalCategorical);
				
				int left,right;
				
				left = intervalCategorical.getLeft();
				right = intervalCategorical.getRight();
				
				for(int i = left; i <= right; i++)
				{
					valueCategorical.setValue(i);
					
					exprTree1 = new ExprTree();
					exprTree2 = new ExprTree();
					
					// Create the exprTree
					exprTree1.addBlock(new Equal());
					exprTree1.addBlock(term.copy());
					exprTree1.addBlock(valueCategorical.copy());
					exprTree2.addBlock(new NotEqual());
					exprTree2.addBlock(term.copy());
					exprTree2.addBlock(valueCategorical.copy());
					
					created.add(exprTree1);
					created.add(exprTree2);
				}
				
				break;
			}
			default:
				System.out.println("Type is not supported");
		}
		
		// Return result
		return created;
	}
}