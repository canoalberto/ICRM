package net.sf.jclec.problem.classification.icrm.ga;

import java.util.Comparator;

import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.base.AbstractParallelEvaluator;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;
import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.icrm.ICRMIndividual;
import net.sf.jclec.problem.classification.rule.Rule;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.IExample;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMGAEvaluator extends AbstractParallelEvaluator
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 3613350191235561000L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** Train Dataset */
	
	protected IDataset dataset;
	
	/** Maximize the fitness function */
	
	private boolean maximize = true;

	/** Fitness comparator */
	
	protected transient ValueFitnessComparator comparator;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 */
	
	public ICRMGAEvaluator()
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------- Getting and setting properties
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Get the dataset 
	 * 
	 * @return dataset
	 */
	
	public IDataset getDataset()
	{
		return this.dataset;
	}
	
	/**
	 * Set the dataset and we keep in memory all the instances
	 * 
	 * @param dataset
	 */
	
	public void setDataset(IDataset dataset)
	{
		this.dataset = dataset;
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------ Overwriting AbstractEvaluator methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Apply function over phenotype, then create a  instance of the
	 * SimpleValueFitness class  with its value set to function value 
	 * and assigns it to the individual and assigns the consequent.
	 * 
	 * @param ind Individual to evaluate
	 */

	public void evaluate(IIndividual ind) 
	{
		// Individual conversion
		Rule rule = (Rule) ((ICRMIndividual) ind).getPhenotype();
		
		int tp = 0, fp = 0, tn = 0, fn = 0;
		
		//Calculate the confusion matrix for each class
		
		for(IExample instance : getDataset().getExamples())
		{
			double value = ((ClassicInstance) instance).getClassValue();
			
			if((Boolean) rule.covers(instance))
			{
				if (value == rule.getConsequent())
					tp++;
				else
					fp++;
			}
			else
			{
				if (value != rule.getConsequent())
					tn++;
				else
					fn++;
			}
		}
		
		double fitness;
		double se, sp;
		
	   	if(tp + fn == 0)
			se = 0;
		else
			se = tp / (double) (tp + fn);

		if(tn + fp == 0)
			sp = 1;
		else
			sp = tn / (double) (tn + fp);
		
	    // Set the fitness to the individual
		fitness = se * sp;
		
		ind.setFitness(new SimpleValueFitness(fitness));
	}
	
	/**
	 * {@inheritDoc}
	 */
	
	public Comparator<IFitness> getComparator() 
	{		
		// Set fitness comparator (if necessary)
		if (comparator == null) 
			comparator = new ValueFitnessComparator(!maximize);

		// Return comparator
		return comparator;
	}
}