package net.sf.jclec.problem.classification.icrm.fitting;

import java.util.Comparator;

import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.base.AbstractParallelEvaluator;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;
import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.classic.classifier.CrispRuleBase;
import net.sf.jclec.problem.classification.exprtree.MultiExprTreeRuleIndividual;
import net.sf.jclec.problem.classification.rule.Rule;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.IExample;

public class ICRMFittingEvaluator extends AbstractParallelEvaluator
{
	/////////////////////////////////////////////////////////////////
	//--------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = 3613350191235561000L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////
	
	/** Train Dataset */

	protected IDataset dataset;

	/** Maximize the fitness function */

	private boolean maximize = true;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------- Internal variables
	// ///////////////////////////////////////////////////////////////

	/** Fitness comparator */

	protected transient ValueFitnessComparator comparator = new ValueFitnessComparator(!maximize);

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 */

	public ICRMFittingEvaluator() {
		super();
	}
	
	public ICRMFittingEvaluator(IDataset dataset) {
		super();
		this.dataset = dataset;
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////

	/**
	 * Get the dataset 
	 * 
	 * @return dataset
	 */
	
	public IDataset getDataset()
	{
		return this.dataset;
	}
	
	/**
	 * Set the dataset and we keep in memory all the instances
	 * 
	 * @param dataset
	 */
	
	public void setDataset(IDataset dataset)
	{
		this.dataset = dataset;
	}
	
	// ///////////////////////////////////////////////////////////////
	// ------------------------ Overwriting AbstractEvaluator methods
	// ///////////////////////////////////////////////////////////////
	
	@Override
	public void evaluate(IIndividual ind) 
	{
		MultiExprTreeRuleIndividual individual = (MultiExprTreeRuleIndividual) ind;
		
		//Calculate the confusion matrix
		int hits = 0;
		
		for(IExample instance : getDataset().getExamples())
		{
			boolean covered = false;
			double value = ((ClassicInstance) instance).getClassValue();
			
			for(int i = 0; i < individual.getPhenotype().getClassificationRules().size(); i++)
			{
				Rule rule = individual.getPhenotype().getClassificationRule(i);
				
				if((Boolean) rule.covers(instance))
				{
					covered = true;
					if (value == rule.getConsequent())
						hits++;
					break;
				}
			}
			
			if(!covered)
				if(value == ((CrispRuleBase) individual.getPhenotype()).getDefaultClass())
					hits++;
		}
		
		double accuracy = hits / (double) getDataset().getExamples().size();
		
		ind.setFitness(new SimpleValueFitness(accuracy));
	}
	
	/**
	 * {@inheritDoc}
	 */
	
	public Comparator<IFitness> getComparator() 
	{		
		// Return comparator
		return comparator;
	}	
}