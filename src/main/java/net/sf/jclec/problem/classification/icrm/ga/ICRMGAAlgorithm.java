package net.sf.jclec.problem.classification.icrm.ga;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IIndividual;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.problem.classification.icrm.ICRMAlgorithm;
import net.sf.jclec.problem.classification.icrm.ICRMExprTreeSpecies;
import net.sf.jclec.problem.classification.icrm.ICRMIndividual;
import net.sf.jclec.problem.util.dataset.IDataset;
import net.sf.jclec.problem.util.dataset.IMetadata;
import net.sf.jclec.problem.util.dataset.attribute.AttributeType;
import net.sf.jclec.selector.BettersSelector;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMGAAlgorithm extends PopulationAlgorithm
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	/** Mutation operator */

	protected ICRMGAMutator mutator;

	/** Training Dataset info */

	private IMetadata trainMetadata;

	/** Number of attributes */

	protected int numberAttributes;

	/** Used in update phase */

	protected BettersSelector bettersSelector = new BettersSelector(this);
	
	protected transient List<IIndividual>[] bset;

	protected transient List<IIndividual>[] pset;

	protected transient List<IIndividual>[] cset;

	protected transient List<IIndividual>[] mset;
	
	public List<IIndividual>[] initialRules;

	/** Class to classify */
	
	public int Class;
	
	/** List of feasible attributes to cover */
	
	private List<Integer> attributes;

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////

	@SuppressWarnings("unchecked")
	public ICRMGAAlgorithm(ICRMAlgorithm parentAlgorithm, int Class, List<IIndividual> initset[], IDataset dataset)
	{
		super();
		this.Class = Class;
		this.numberAttributes = initset.length;
		
		pset = new ArrayList[numberAttributes];
		bset = new ArrayList[numberAttributes];
		cset = new ArrayList[numberAttributes];
		mset = new ArrayList[numberAttributes];
		
		for(int i = 0; i < numberAttributes; i++)
		{
			bset[i] = new ArrayList<IIndividual>();
			mset[i] = new ArrayList<IIndividual>();
			
			for(IIndividual ind : initset[i])
			{
				bset[i].add(ind.copy());
			}
		}
		
		randGenFactory = parentAlgorithm.getRandGenFactory();
		species = parentAlgorithm.getSpecies();
		evaluator = new ICRMGAEvaluator();
		((ICRMGAEvaluator) evaluator).setDataset(dataset);
		
		attributes = new ArrayList<Integer>();
		
		for(int i = 0; i < numberAttributes; i++)
		{
			if(((ICRMExprTreeSpecies) parentAlgorithm.getSpecies()).getMetadata().getAttribute(i).getType() != AttributeType.Categorical && bset[i].size() > 0)
				attributes.add(i);
			else
			{
				for (IIndividual ind : bset[i])
					((ICRMIndividual) ind).getPhenotype().setConsequent(Class);
				
				evaluator.evaluate(bset[i]);
				
				bset[i] = bettersSelector.select(bset[i]);
			}
		}
		
		setMaxOfGenerations(10);

		// Mutator
		mutator = new ICRMGAMutator(this);
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////


	/**
	 * @return the numberAttributes
	 */
	public int getNumberAttributes() {
		return numberAttributes;
	}

	/**
	 * @param numberAttributes
	 *            the numberAttributes to set
	 */
	public void setNumberAttributes(int numberAttributes) {
		this.numberAttributes = numberAttributes;
	}

	/**
	 * Access to "trainMetadata" property.
	 * 
	 * @return trainMetadata
	 */

	public IMetadata getTrainMetadata() {
		return this.trainMetadata;
	}

	/**
	 * Set the "trainMetadata" property.
	 * 
	 * @param trainMetadata
	 */

	public void setTrainMetadata(IMetadata train) {
		this.trainMetadata = train;
	}
	
	public List<IIndividual> getInhabitants(int attribute)
	{
		return bset[attribute];
	}

	// ///////////////////////////////////////////////////////////////
	// ---------------------------- Overwriting BaseAlgorithm methods
	// ///////////////////////////////////////////////////////////////

	@Override
	protected void doInit()
	{
		for(int i : attributes)
		{
			for (IIndividual ind : bset[i])
				((ICRMIndividual) ind).getPhenotype().setConsequent(Class);
			
			evaluator.evaluate(bset[i]);
		}
	}

	@Override
	protected void doSelection()
	{
		for(int i : attributes)
		{
			pset[i] = new ArrayList<IIndividual>();
			pset[i].addAll(bset[i]);
	
			cset[i] = new ArrayList<IIndividual>();
			cset[i].addAll(pset[i]);
		}
	}

	@Override
	protected void doGeneration()
	{
		for(int i : attributes)
		{
			// Mutate parents
			mset[i] = mutator.mutate(pset[i]);
			
			List<IIndividual> nonDuplicatedSet = new ArrayList<IIndividual>();
			
			for(IIndividual ind : mset[i])
				if(!nonDuplicatedSet.contains(ind))
					nonDuplicatedSet.add(ind);
			
			for (IIndividual ind : nonDuplicatedSet)
				((ICRMIndividual) ind).getPhenotype().setConsequent(Class);
	
			evaluator.evaluate(nonDuplicatedSet);
	
			cset[i].addAll(nonDuplicatedSet);
		}
	}

	@Override
	protected void doReplacement() {
	}

	@Override
	protected void doUpdate()
	{
		for(int i : attributes)
		{
			if(cset[i].size() >= 10)
				bset[i] = bettersSelector.select(cset[i], 10);
			else
				bset[i] = bettersSelector.select(cset[i]);
		}
	}

	@Override
	protected void doControl()
	{
		if (maxOfGenerations >= maxOfGenerations)
		{
			state = FINISHED;
			return;
		}
	}
}