package net.sf.jclec.problem.classification.icrm;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

import net.sf.jclec.IIndividual;
import net.sf.jclec.fitness.IValueFitness;
import net.sf.jclec.problem.classification.ClassificationAlgorithm;
import net.sf.jclec.problem.classification.classic.ClassicClassificationMetadata;
import net.sf.jclec.problem.classification.classic.listener.RuleBaseReporter;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMPopulationReport extends RuleBaseReporter
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = -8548482239030974796L;

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Constructor
	 */
	
	public ICRMPopulationReport() 
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////

	/**
	 * Make a report with individuals and their fitness for this generation
	 * 
	 * @param Falco algorithm
	 */
	protected void doIterationReport(ClassificationAlgorithm abstractalgorithm)
	{
		ICRMAlgorithm algorithm = (ICRMAlgorithm) abstractalgorithm;
		// Population individuals
		List<IIndividual> inds = null;
		// Actual generation
		int generation = algorithm.getGeneration();
		
		if (generation%reportFrequency == 0) 
		{		
			// Serialize this report in 'iterationXXX.rep' file
			String reportFilename = String.format("Iteration_%d_%d.rep", algorithm.getTrainSet().getMetadata().numberOfClasses() - algorithm.getCoveredClasses().size(), generation);
			
			try {
				// Report file
				File reportFile = new File(reportDirectory, reportFilename);
				// Report writer
				FileWriter reportWriter = null;
				
				try {
						reportFile.createNewFile();
						reportWriter = new FileWriter (reportFile);
				}
				catch(IOException e3){
					e3.printStackTrace();
				}
				
				StringBuffer buffer = new StringBuffer();
				ClassicClassificationMetadata metadata = (ClassicClassificationMetadata) algorithm.getTrainSet().getMetadata();
				
				for(int i : algorithm.getCoveredClasses())
				{
					buffer.append("Class " + metadata.getAttribute(metadata.getClassIndex()).show(i) + "\n");
					
						inds = algorithm.getInhabitants(i);
						
						//Prints individuals
						for(int k=0; k<inds.size(); k++)
						{
							ICRMIndividual ind = (ICRMIndividual) inds.get(k);
							buffer.append(ind + "; Fitness: " + ((IValueFitness) inds.get(k).getFitness()).getValue()+"\n"); 
						}
				}
				
				reportWriter.append(buffer.toString());
				reportWriter.close();
			} 
			catch (IOException e) {
				throw new RuntimeException("Error writing report file");
			}
		}
	}
}
