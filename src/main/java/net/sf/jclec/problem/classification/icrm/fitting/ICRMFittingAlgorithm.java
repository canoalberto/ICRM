package net.sf.jclec.problem.classification.icrm.fitting;

import java.util.ArrayList;
import java.util.List;

import net.sf.jclec.IEvaluator;
import net.sf.jclec.IIndividual;
import net.sf.jclec.algorithm.PopulationAlgorithm;
import net.sf.jclec.exprtree.ExprTree;
import net.sf.jclec.problem.classification.classic.classifier.CrispRuleBase;
import net.sf.jclec.problem.classification.exprtree.MultiExprTreeRuleIndividual;
import net.sf.jclec.problem.classification.icrm.ICRMAlgorithm;
import net.sf.jclec.problem.util.dataset.IMetadata;
import net.sf.jclec.selector.BettersSelector;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMFittingAlgorithm extends PopulationAlgorithm
{
	// ///////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	// ///////////////////////////////////////////////////////////////

	/** Generated by Eclipse */

	private static final long serialVersionUID = -8711970425735016406L;

	// ///////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	// ///////////////////////////////////////////////////////////////

	/** Mutation operator */

	protected ICRMFittingMutator mutator;

	/** Training Dataset info */

	private IMetadata trainMetadata;

	/** Used in update phase */

	protected BettersSelector bettersSelector = new BettersSelector(this);
	
	protected transient List<IIndividual> mset;
	
	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	// ///////////////////////////////////////////////////////////////
	
	public ICRMFittingAlgorithm(ICRMAlgorithm parentAlgorithm, CrispRuleBase classifier, IEvaluator evaluator)
	{
		super();
		
		pset = new ArrayList<IIndividual>();
		bset = new ArrayList<IIndividual>();
		cset = new ArrayList<IIndividual>();
		mset = new ArrayList<IIndividual>();
		
		this.evaluator = evaluator;
		
		ExprTree[] genotype = new ExprTree[classifier.getClassificationRules().size()];

		for(int i = 0; i < classifier.getClassificationRules().size(); i++)
			genotype[i] = classifier.getClassificationRule(i).getAntecedent();
		
		MultiExprTreeRuleIndividual seed = new MultiExprTreeRuleIndividual(genotype, classifier);
		
		bset.add(seed);
		
		randGenFactory = parentAlgorithm.getRandGenFactory();
		species = parentAlgorithm.getSpecies();
		evaluator = new ICRMFittingEvaluator();
		
		setMaxOfGenerations(100);

		// Mutator
		mutator = new ICRMFittingMutator(this);
	}

	// ///////////////////////////////////////////////////////////////
	// ------------------------------------------------ Public methods
	// ///////////////////////////////////////////////////////////////


	/**
	 * Access to "trainMetadata" property.
	 * 
	 * @return trainMetadata
	 */

	public IMetadata getTrainMetadata() {
		return this.trainMetadata;
	}

	/**
	 * Set the "trainMetadata" property.
	 * 
	 * @param trainMetadata
	 */

	public void setTrainMetadata(IMetadata train) {
		this.trainMetadata = train;
	}
	
	// ///////////////////////////////////////////////////////////////
	// ---------------------------- Overwriting BaseAlgorithm methods
	// ///////////////////////////////////////////////////////////////

	@Override
	protected void doInit()
	{
		evaluator.evaluate(bset);
	}

	@Override
	protected void doSelection()
	{
		pset = new ArrayList<IIndividual>();
		pset.addAll(bset);
		
		cset = new ArrayList<IIndividual>();
		cset.addAll(pset);
	}

	@Override
	protected void doGeneration()
	{
		// Mutate parents
		mset = mutator.mutate(pset);
		
		List<IIndividual> nonDuplicatedSet = new ArrayList<IIndividual>();
		
		for(IIndividual ind : mset)
			if(!nonDuplicatedSet.contains(ind))
				nonDuplicatedSet.add(ind);
		
		evaluator.evaluate(nonDuplicatedSet);

		cset.addAll(nonDuplicatedSet);
	}

	@Override
	protected void doReplacement() {
	}

	@Override
	protected void doUpdate()
	{
		if(cset.size() >= 5)
			bset = bettersSelector.select(cset, 5);
		else
			bset = bettersSelector.select(cset);
	}

	@Override
	protected void doControl()
	{
		if (maxOfGenerations >= maxOfGenerations)
		{
			state = FINISHED;
			return;
		}
	}
}