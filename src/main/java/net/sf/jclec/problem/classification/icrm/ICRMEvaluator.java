package net.sf.jclec.problem.classification.icrm;

import java.util.ArrayList;
import java.util.Comparator;

import net.sf.jclec.IFitness;
import net.sf.jclec.IIndividual;
import net.sf.jclec.base.AbstractParallelEvaluator;
import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;
import net.sf.jclec.problem.classification.classic.ClassicClassificationMetadata;
import net.sf.jclec.problem.classification.classic.ClassicInstance;
import net.sf.jclec.problem.classification.rule.Rule;
import net.sf.jclec.problem.util.dataset.IExample;

/**
 * ICRM: An Interpretable Classification Rule Mining algorithm
 * 
 * @author Alberto Cano 
 * @author Amelia Zafra
 * @author Sebastian Ventura
 */

public class ICRMEvaluator extends AbstractParallelEvaluator
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------- Serialization constant
	/////////////////////////////////////////////////////////////////

	/** Generated by Eclipse */
	
	private static final long serialVersionUID = 3613350191235561000L;

	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Properties
	/////////////////////////////////////////////////////////////////
	
	/** Maximize the fitness function */
	
	private boolean maximize = true;

	/** Fitness comparator */
	
	protected transient ValueFitnessComparator comparator;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Empty constructor.
	 */
	
	public ICRMEvaluator()
	{
		super();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------ Overwriting AbstractEvaluator methods
	/////////////////////////////////////////////////////////////////
	
	/**
	 * Apply function over phenotype, then create a  instance of the
	 * SimpleValueFitness class  with its value set to function value 
	 * and assigns it to the individual and assigns the consequent.
	 * 
	 * @param ind Individual to evaluate
	 */

	public void evaluate(IIndividual ind) 
	{
		// Individual conversion
		Rule rule = (Rule) ((ICRMIndividual) ind).getPhenotype();
		
		int tp = 0, fp = 0, tn = 0, fn = 0;
		
		ClassicClassificationMetadata metadata = (ClassicClassificationMetadata) ((ICRMIndividual) ind).getDataset().getMetadata();
		
		//Calculate the confusion matrix for each class
		
		ArrayList<IExample> coveredInstances = new ArrayList<IExample>();
		
		for(IExample instance : ((ICRMIndividual) ind).getDataset().getExamples())
		{
			double value = ((ClassicInstance) instance).getClassValue();
			
			if((Boolean) rule.covers(instance))
			{
				coveredInstances.add(instance);
				if (value == rule.getConsequent())
					tp++;
				else
					fp++;
			}
			else
			{
				if (value != rule.getConsequent())
					tn++;
				else
					fn++;
			}
		}
		
		((ICRMIndividual) ind).getDataset().setExamples(coveredInstances);
		
		double fitness;
		double se, sp;
		
	   	if(tp + fn == 0)
			se = 0;
		else
			se =  tp / (double) (tp + fn);

		if(tn + fp == 0)
			sp = 1;
		else
			sp =  tn / (double) (tn + fp);
		
		
	    // Set the fitness to the individual
		fitness = se * sp - 0.01*((rule.getAntecedent().size()/3)/(double)(metadata.numberOfAttributes()));
		
		ind.setFitness(new SimpleValueFitness(fitness));
	}
	
	/**
	 * {@inheritDoc}
	 */
	
	public Comparator<IFitness> getComparator() 
	{		
		// Set fitness comparator (if necessary)
		if (comparator == null) 
			comparator = new ValueFitnessComparator(!maximize);

		// Return comparator
		return comparator;
	}
}